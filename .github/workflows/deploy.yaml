name: Deploy to Production

on:
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_SSH_PORT }}
          script: |
            set -e  # Exit on any error

            PROJECT_DIR="/home/${{ secrets.SERVER_USER }}/AEGIS"

            # Create project directory if it doesn't exist
            mkdir -p "$PROJECT_DIR"
            cd "$PROJECT_DIR"

            # Backup critical files before pull
            echo "Backing up critical configuration files..."
            mkdir -p .backup
            [ -f .env ] && cp .env .backup/.env.bak
            [ -f docker-compose.yml ] && cp docker-compose.yml .backup/docker-compose.yml.bak
            [ -f nginx.conf ] && cp nginx.conf .backup/nginx.conf.bak
            [ -d api/certs ] && cp -r api/certs .backup/certs.bak 2>/dev/null || true

            # Initialize git repository if it doesn't exist
            if [ ! -d ".git" ]; then
              echo "Initializing git repository..."
              git init
              git remote add origin https://github.com/COS301-SE-2025/AEGIS.git
            fi

            # Clean up any merge conflicts from previous failed deployments
            echo "Cleaning up any existing merge conflicts..."
            git merge --abort 2>/dev/null || true
            git reset --hard 2>/dev/null || true

            # Fetch latest changes
            echo "Fetching latest code..."
            git fetch origin main

            # Force checkout main branch with latest code
            echo "Checking out main branch..."
            git checkout -B main origin/main

            echo "Successfully pulled latest code"

            # Restore backed up configuration files if they exist
            echo "Restoring configuration files..."
            [ -f .backup/.env.bak ] && cp .backup/.env.bak .env

            # Restore certificates if they exist in backup
            if [ -d ".backup/certs.bak" ]; then
              echo "Restoring SSL certificates..."
              mkdir -p api/certs
              cp -r .backup/certs.bak/* api/certs/ 2>/dev/null || true
            fi

            # Only restore docker-compose.yml if it has custom configurations
            if [ -f .backup/docker-compose.yml.bak ]; then
              echo "Note: Using docker-compose.yml from repository"
              echo "Previous docker-compose.yml backed up at .backup/docker-compose.yml.bak"
            fi

            # Restore nginx.conf if it exists in backup
            if [ -f .backup/nginx.conf.bak ]; then
              echo "Note: Using nginx.conf from repository"
              echo "Previous nginx.conf backed up at .backup/nginx.conf.bak"
            fi

            # Ensure environment file exists
            if [ ! -f ".env" ] && [ -f ".env.example" ]; then
              echo "Creating .env from .env.example..."
              cp .env.example .env
              echo "WARNING: Please update .env with production values!"
            fi

            # Handle SSL certificates - generate self-signed if none exist
            if [ ! -f "api/certs/localhost.pem" ] || [ ! -f "api/certs/localhost-key.pem" ]; then
              echo "Generating self-signed SSL certificates..."
              mkdir -p api/certs
              
              # Generate self-signed certificate valid for 365 days
              openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                -keyout api/certs/localhost-key.pem \
                -out api/certs/localhost.pem \
                -subj "/C=US/ST=State/L=City/O=Organization/OU=OrgUnit/CN=localhost" \
                2>/dev/null || echo "Certificate generation completed"
              
              echo "✓ Generated self-signed certificates"
            fi

            # Validate docker-compose.yml syntax
            echo "Validating docker-compose.yml..."
            if ! docker compose config > /dev/null 2>&1; then
              echo "Error: docker-compose.yml has syntax errors"
              docker compose config || true
              echo "Attempting to use backup..."
              if [ -f .backup/docker-compose.yml.bak ]; then
                cp .backup/docker-compose.yml.bak docker-compose.yml
                echo "Restored backup docker-compose.yml"
              else
                echo "No backup available. Please fix docker-compose.yml manually."
                exit 1
              fi
            fi

            # Verify Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Error: Docker is not installed on the server" >&2
              exit 1
            fi

            # Determine Docker Compose command
            if docker compose version &> /dev/null; then
              COMPOSE_CMD="docker compose"
            elif command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              echo "Error: Docker Compose is not installed" >&2
              exit 1
            fi

            echo "Stopping existing containers..."
            $COMPOSE_CMD down --remove-orphans || true

            echo "Removing old images to force rebuild..."
            docker images | grep aegis | awk '{print $3}' | xargs -r docker rmi -f || true

            echo "Pruning unused Docker resources..."
            docker system prune -f || true

            echo "Building and starting containers..."
            if ! $COMPOSE_CMD up -d --build --force-recreate; then
              echo "Deployment failed! Rolling back to previous state..."
              if [ -f .backup/docker-compose.yml.bak ]; then
                cp .backup/docker-compose.yml.bak docker-compose.yml
                $COMPOSE_CMD up -d
              fi
              exit 1
            fi

            echo "Waiting for services to stabilize..."
            sleep 10

            echo "Container status:"
            $COMPOSE_CMD ps

            echo "Recent logs:"
            $COMPOSE_CMD logs --tail=30

            # Health check for critical services
            echo "Performing health checks..."
            sleep 5

            # Check if API is responding
            if docker ps | grep -q "aegis.*api"; then
              echo "✓ API container is running"
            else
              echo "✗ API container failed to start" >&2
              $COMPOSE_CMD logs api
            fi

            # Check if frontend is responding
            if docker ps | grep -q "aegis.*frontend"; then
              echo "✓ Frontend container is running"
            else
              echo "✗ Frontend container failed to start" >&2
              $COMPOSE_CMD logs frontend
            fi

            # Check if nginx is responding
            if docker ps | grep -q "nginx"; then
              echo "✓ Nginx container is running"
            else
              echo "✗ Nginx container failed to start" >&2
              $COMPOSE_CMD logs nginx
            fi

            echo "============================================"
            echo "✓ Deployment completed successfully!"
            echo "============================================"
            echo "Deployed commit: $(git rev-parse --short HEAD)"
            echo "Backup location: $PROJECT_DIR/.backup"
            echo "SSL certificates location: $PROJECT_DIR/api/certs"
            echo "============================================"
