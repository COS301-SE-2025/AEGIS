package auditlog

import (
	"context"
	"fmt"
	"time"

	"github.com/gin-gonic/gin"
)

type AuditLogger struct {
	mongo MongoLoggerInterface
	zap   ZapLoggerInterface
}

func NewAuditLogger(mongo MongoLoggerInterface, zap ZapLoggerInterface) *AuditLogger {
	return &AuditLogger{mongo: mongo, zap: zap}
}
func (a *AuditLogger) Log(ctx *gin.Context, log AuditLog) error {
	// Mongo log (persistent)
	if err := a.mongo.Log(ctx, log); err != nil {
		return err
	}

	// Zap log (console)
	a.zap.Log(log)

	return nil
}

// LogDownloadReport method now accepts context.Context

// LogDownloadReport method now accepts context.Context
func (a *AuditLogger) LogDownloadReport(ctx context.Context, reportID string, userID string, userRole string, userAgent string, ipAddress string, email string, timestamp time.Time) error {
	// Type assertion to check if ctx is a *gin.Context
	ginCtx, ok := ctx.(*gin.Context)
	if !ok {
		return fmt.Errorf("context is not of type *gin.Context")
	}

	// Create the Actor object with the necessary user details
	actor := Actor{
		ID:        userID,
		Role:      userRole,
		UserAgent: userAgent,
		IPAddress: ipAddress,
		Email:     email,
	}

	// Create the Target object representing the downloaded report
	target := Target{
		Type:           "report",
		ID:             reportID,
		AdditionalInfo: map[string]string{},
	}

	// Create the AuditLog entry
	log := AuditLog{
		ID:          "",
		Timestamp:   timestamp,
		Action:      "DOWNLOAD_REPORT",
		Actor:       actor,
		Target:      target,
		Service:     "report",
		Status:      "SUCCESS",
		Description: fmt.Sprintf("Report %s downloaded by user %s", reportID, userID),
		Metadata:    map[string]string{"route": "/download", "method": "GET"},
	}

	// Log the entry to MongoDB (persistent log)
	if err := a.mongo.Log(ginCtx, log); err != nil {
		return fmt.Errorf("failed to log to MongoDB: %w", err)
	}

	// Log the entry to Zap (console log)
	a.zap.Log(log)

	// Return nil if no errors occurred
	return nil
}

// LogGenerateReport method logs the generation of a new report
// LogGenerateReport method logs the generation of a new report

// LogGenerateReport method logs the generation of a new report
func (a *AuditLogger) LogGenerateReport(ctx context.Context, reportID string, userID string, userRole string, userAgent string, ipAddress string, email string) error {
	// Generate the timestamp here, using the current time
	timestamp := time.Now()

	// Type assertion to ensure ctx is a *gin.Context
	ginCtx, ok := ctx.(*gin.Context)
	if !ok {
		return fmt.Errorf("context is not of type *gin.Context")
	}

	// Create the Actor object with the necessary user details
	actor := Actor{
		ID:        userID,
		Role:      userRole,
		UserAgent: userAgent,
		IPAddress: ipAddress,
		Email:     email,
	}

	// Create the Target object representing the newly generated report
	target := Target{
		Type:           "report",            // This could be "report" or any other identifier
		ID:             reportID,            // The generated report's ID
		AdditionalInfo: map[string]string{}, // Additional info can be added here if needed
	}

	// Create the AuditLog entry for generating a report
	log := AuditLog{
		ID:          "", // You may generate a UUID here
		Timestamp:   timestamp,
		Action:      "GENERATE_REPORT", // Action type for generating a report
		Actor:       actor,
		Target:      target,
		Service:     "report",  // The service that triggered the log
		Status:      "SUCCESS", // Assume success, this can be changed based on the outcome
		Description: fmt.Sprintf("Report %s generated by user %s", reportID, userID),
		Metadata:    map[string]string{"route": "/generate", "method": "POST"},
	}

	// Log the entry to MongoDB (persistent log)
	if err := a.mongo.Log(ginCtx, log); err != nil {
		return fmt.Errorf("failed to log to MongoDB: %w", err)
	}

	// Log the entry to Zap (console log)
	a.zap.Log(log)

	// Return nil if no errors occurred
	return nil
}

// LogDeleteReport logs the deletion of a report
func (a *AuditLogger) LogDeleteReport(ctx context.Context, reportID, userID, userRole, userAgent, ipAddress, email string, timestamp time.Time) error {
	// Create the Actor object with the necessary user details
	actor := Actor{
		ID:        userID,
		Role:      userRole,
		UserAgent: userAgent,
		IPAddress: ipAddress,
		Email:     email,
	}
	// Type assertion to ensure ctx is a *gin.Context
	ginCtx, ok := ctx.(*gin.Context)
	if !ok {
		return fmt.Errorf("context is not of type *gin.Context")
	}

	// Create the Target object representing the deleted report
	target := Target{
		Type:           "report",            // This could be "report" or any other identifier
		ID:             reportID,            // The report's ID
		AdditionalInfo: map[string]string{}, // Additional info can be added here if needed
	}

	// Create the AuditLog entry for the report deletion
	log := AuditLog{
		ID:          "", // You may generate a UUID here
		Timestamp:   timestamp,
		Action:      "DELETE_REPORT", // Action type for deleting a report
		Actor:       actor,
		Target:      target,
		Service:     "report",  // The service that triggered the log
		Status:      "SUCCESS", // Assume success, this can be changed based on the outcome
		Description: fmt.Sprintf("Report %s deleted by user %s", reportID, userID),
		Metadata:    map[string]string{"route": "/delete", "method": "DELETE"},
	}

	// Log the entry to MongoDB (persistent log)
	if err := a.mongo.Log(ginCtx, log); err != nil {
		return fmt.Errorf("failed to log to MongoDB: %w", err)
	}

	// Log the entry to Zap (console log)
	a.zap.Log(log)

	// Return nil if no errors occurred
	return nil
}
