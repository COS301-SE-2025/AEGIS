package report_ai_assistance

import (
	"fmt"
	"regexp"
	"strings"
)

// PostProcessEnhancedSummary cleans up AI-generated summary output by removing boilerplate and repeated lines.
func PostProcessEnhancedSummary(text string) string {
	// If input looks like structured case info, humanize it
	if strings.Contains(text, "Case Title:") && strings.Contains(text, "Status:") {
		return humanizeCaseInfo(text)
	}
	if strings.Contains(text, "Evidence:") {
		// Try to extract IOCs from context if available
		var iocs []IOC
		// Try to extract from a global context (if available)
		// This is a stub: in real use, pass iocs from payload
		// If you want to pass iocs from the payload, update the handler to call humanizeEvidence(text, iocs)
		return humanizeEvidence(text, iocs)
	}
	if strings.Contains(text, "Timeline Event") {
		return humanizeTimeline(text)
	}
	// Replace technical jargon with simple terms
	replacements := map[string]string{
		"protocol":   "rules",
		"securely":   "safely",
		"procedures": "steps",
		"collected":  "gathered",
		"evidence":   "proof",
		"stored":     "kept",
		"as per":     "according to",
	}
	// Remove boilerplate phrases
	boilerplate := []string{
		"This summary was generated by AI.",
		"Please review and edit as needed.",
		"In summary:",
	}
	// Split into sentences (simple period-based split)
	sentences := splitSentences(text)
	result := ""
	for _, s := range sentences {
		trimmed := trimSpace(s)
		if trimmed == "" {
			continue
		}
		skip := false
		for _, b := range boilerplate {
			if trimmed == b {
				skip = true
				break
			}
		}
		if skip {
			continue
		}
		// Replace jargon
		for k, v := range replacements {
			trimmed = replaceWord(trimmed, k, v)
		}
		// Shorten sentence if possible
		if len(trimmed) > 120 {
			trimmed = shortenSentence(trimmed)
		}
		result += trimmed + ". "
	}
	return result
}

// humanizeCaseInfo parses key-value pairs and generates a readable summary
func humanizeCaseInfo(text string) string {
	// Parse multi-line key-value pairs robustly
	fields := map[string]string{}
	lines := strings.Split(text, "\n")
	for _, line := range lines {
		kv := strings.SplitN(line, ":", 2)
		if len(kv) == 2 {
			key := strings.TrimSpace(kv[0])
			val := strings.TrimSpace(kv[1])
			fields[key] = val
		}
	}
	// Build a more humanized summary
	var parts []string
	if t, ok := fields["Case Title"]; ok {
		parts = append(parts, fmt.Sprintf("Case '%s'", t))
	}
	if desc, ok := fields["Description"]; ok {
		parts = append(parts, fmt.Sprintf("involves %s", desc))
	}
	if s, ok := fields["Status"]; ok {
		parts = append(parts, fmt.Sprintf("and is currently %s", s))
	}
	if prio, ok := fields["Priority"]; ok {
		parts = append(parts, fmt.Sprintf("with a priority of %s", prio))
	}
	if stg, ok := fields["Stage"]; ok {
		parts = append(parts, fmt.Sprintf("(stage: %s)", stg))
	}
	if team, ok := fields["Team"]; ok {
		parts = append(parts, fmt.Sprintf("handled by team %s", team))
	}
	if created, ok := fields["Created"]; ok {
		parts = append(parts, fmt.Sprintf("created on %s", created))
	}
	if updated, ok := fields["Last Updated"]; ok {
		parts = append(parts, fmt.Sprintf("last updated on %s", updated))
	}
	if examiner, ok := fields["Examiner"]; ok {
		parts = append(parts, fmt.Sprintf("examined by %s", examiner))
	}
	if cid, ok := fields["Case ID"]; ok {
		parts = append(parts, fmt.Sprintf("(Case ID: %s)", cid))
	}
	summary := strings.Join(parts, ", ") + "."
	return summary
}

// Humanize evidence block (stub)
type IOC struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

func humanizeEvidence(text string, iocs []IOC) string {
	// Parse evidence lines and IOCs
	lines := strings.Split(text, "\n")
	var evidenceItems []string
	var iocItems []string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "Evidence:") {
			// ...existing code for evidence...
			item := strings.TrimPrefix(line, "Evidence:")
			var hashes string
			idx := strings.Index(text, line)
			if idx != -1 {
				hashLines := lines
				for _, hline := range hashLines {
					hline = strings.TrimSpace(hline)
					if strings.HasPrefix(hline, "Hashes:") {
						hashes = strings.TrimPrefix(hline, "Hashes:")
					}
				}
			}
			if hashes != "" {
				evidenceItems = append(evidenceItems, fmt.Sprintf("%s (Hashes: %s)", item, hashes))
			} else {
				evidenceItems = append(evidenceItems, item)
			}
		} else if strings.HasPrefix(line, "Indicator ") {
			// Humanize IOCs for all supported types
			ioc := strings.TrimPrefix(line, "Indicator ")
			parts := strings.SplitN(ioc, ":", 2)
			if len(parts) == 2 {
				iocNum := strings.TrimSpace(parts[0])
				iocRest := strings.TrimSpace(parts[1])
				iocTypeVal := strings.SplitN(iocRest, "-", 2)
				if len(iocTypeVal) == 2 {
					iocType := strings.TrimSpace(iocTypeVal[0])
					iocVal := strings.TrimSpace(iocTypeVal[1])
					switch strings.ToLower(iocType) {
					case "ip":
						iocItems = append(iocItems, fmt.Sprintf("Suspicious IP address detected: %s", iocVal))
					case "email":
						iocItems = append(iocItems, fmt.Sprintf("Malicious email identified: %s", iocVal))
					case "domain":
						iocItems = append(iocItems, fmt.Sprintf("Malicious domain detected: %s", iocVal))
					case "url":
						iocItems = append(iocItems, fmt.Sprintf("Malicious URL detected: %s", iocVal))
					case "hash":
						iocItems = append(iocItems, fmt.Sprintf("Suspicious file hash detected: %s", iocVal))
					default:
						iocItems = append(iocItems, fmt.Sprintf("IOC %s: %s (%s)", iocNum, iocVal, iocType))
					}
				} else {
					iocItems = append(iocItems, fmt.Sprintf("IOC %s: %s", iocNum, iocRest))
				}
			} else {
				iocItems = append(iocItems, ioc)
			}
		}
	}

	// Also process structured IOCs if available
	for _, ioc := range iocs {
		switch strings.ToLower(ioc.Type) {
		case "ip":
			iocItems = append(iocItems, fmt.Sprintf("Suspicious IP address detected: %s", ioc.Value))
		case "email":
			iocItems = append(iocItems, fmt.Sprintf("Malicious email identified: %s", ioc.Value))
		case "domain":
			iocItems = append(iocItems, fmt.Sprintf("Malicious domain detected: %s", ioc.Value))
		case "url":
			iocItems = append(iocItems, fmt.Sprintf("Malicious URL detected: %s", ioc.Value))
		case "hash":
			iocItems = append(iocItems, fmt.Sprintf("Suspicious file hash detected: %s", ioc.Value))
		default:
			iocItems = append(iocItems, fmt.Sprintf("IOC: %s (%s)", ioc.Value, ioc.Type))
		}
	}
	summary := "Collected evidence includes: "
	if len(evidenceItems) > 0 {
		summary += strings.Join(evidenceItems, "; ") + ". "
	}
	if len(iocItems) > 0 {
		summary += "Indicators of compromise: " + strings.Join(iocItems, "; ") + ". "
	}
	return summary
}

// Humanize timeline block (stub)
func humanizeTimeline(text string) string {
	// Parse timeline events
	lines := strings.Split(text, "\n")
	var events []string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "Timeline Event") {
			events = append(events, line)
		}
	}
	if len(events) == 0 {
		return "No timeline events found."
	}
	summary := "Key timeline events: " + strings.Join(events, "; ") + "."
	return summary
}

func splitSentences(s string) []string {
	// Naive split by period
	var out []string
	curr := ""
	for _, r := range s {
		curr += string(r)
		if r == '.' {
			out = append(out, curr)
			curr = ""
		}
	}
	if curr != "" {
		out = append(out, curr)
	}
	return out
}
func trimSpace(s string) string {
	// Remove leading/trailing whitespace
	return strings.TrimSpace(s)
}

func replaceWord(s, old, new string) string {
	// Replace whole word only (case-insensitive)
	re := regexp.MustCompile(`\b` + regexp.QuoteMeta(old) + `\b`)
	return re.ReplaceAllString(s, new)
}

func shortenSentence(s string) string {
	// Naive shortening: keep first 15 words
	words := []rune(s)
	if len(words) > 120 {
		return string(words[:120]) + "..."
	}
	return s
}
