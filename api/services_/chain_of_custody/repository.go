// services_/coc/repo_gorm.go
package coc

import (
	"context"
	"time"

	"gorm.io/gorm"
)

// --- Model maps 1:1 to your chain_of_custody table ---
// NOTE: Do NOT run AutoMigrate on this model since you created the table,
// enum type, and triggers via SQL migrations already.
type CoCEntryModel struct {
	ID         string  `gorm:"column:id;type:uuid;primaryKey"` // generated by DB default gen_random_uuid()
	CaseID     string  `gorm:"column:case_id;type:uuid;not null;index:idx_coc_case_time,priority:1"`
	EvidenceID string  `gorm:"column:evidence_id;type:uuid;not null;index:idx_coc_evidence_time,priority:1"`
	ActorID    *string `gorm:"column:actor_id;type:uuid;index:idx_coc_actor"`
	Action     Action  `gorm:"column:action;type:coc_action;not null;index:idx_coc_action"`
	//Reason     *string   `gorm:"column:reason;type:text"`
	Location   *string   `gorm:"column:location;type:text"`
	HashMD5    *string   `gorm:"column:hash_md5;type:text"`
	HashSHA1   *string   `gorm:"column:hash_sha1;type:text"`
	HashSHA256 *string   `gorm:"column:hash_sha256;type:text"`
	OccurredAt time.Time `gorm:"column:occurred_at;type:timestamptz;not null;index:idx_coc_case_time,priority:2;index:idx_coc_evidence_time,priority:2"`
	CreatedAt  time.Time `gorm:"column:created_at;type:timestamptz;not null"`
}

func (CoCEntryModel) TableName() string { return "chain_of_custody" }

// Optional: guard against accidental updates/deletes at the ORM layer too.
// DB already blocks them via triggers, but this gives nicer errors.
func (CoCEntryModel) BeforeUpdate(tx *gorm.DB) error { return gorm.ErrInvalidData }
func (CoCEntryModel) BeforeDelete(tx *gorm.DB) error { return gorm.ErrInvalidData }

// --- Repo interface stays the same ---
type GormRepo struct{ DB *gorm.DB }

// Insert creates a new CoC row (append-only).
func (r GormRepo) Insert(ctx context.Context, p LogParams) (string, error) {
	m := CoCEntryModel{
		CaseID:     p.CaseID,
		EvidenceID: p.EvidenceID,
		ActorID:    p.ActorID,
		Action:     p.Action,
		//Reason:     p.Reason,
		Location:   p.Location,
		HashMD5:    p.HashMD5,
		HashSHA1:   p.HashSHA1,
		HashSHA256: p.HashSHA256,
		OccurredAt: p.OccurredAt, // service should default this if zero
		// CreatedAt is DB default NOW(); we let DB set it.
	}

	if err := r.DB.WithContext(ctx).Create(&m).Error; err != nil {
		return "", err
	}
	return m.ID, nil
}

// ListByEvidence returns entries for an evidence item with optional filters/pagination.
func (r GormRepo) ListByEvidence(ctx context.Context, evidenceID string, f ListFilters) ([]Entry, error) {
	var rows []CoCEntryModel

	q := r.DB.WithContext(ctx).
		Model(&CoCEntryModel{}).
		Scopes(
			scopeEvidence(evidenceID),
			scopeAction(f.Action),
			scopeActor(f.ActorID),
			scopeSince(f.Since),
			scopeUntil(f.Until),
			scopeOrder(), // occurred_at asc, created_at asc
			scopePaginate(f.Limit, f.Offset),
		)

	if err := q.Find(&rows).Error; err != nil {
		return nil, err
	}

	// Map to DTO
	out := make([]Entry, 0, len(rows))
	for _, r := range rows {
		out = append(out, Entry{
			ID:         r.ID,
			CaseID:     r.CaseID,
			EvidenceID: r.EvidenceID,
			ActorID:    r.ActorID,
			Action:     r.Action,
			//Reason:     r.Reason,
			Location:   r.Location,
			HashMD5:    r.HashMD5,
			HashSHA1:   r.HashSHA1,
			HashSHA256: r.HashSHA256,
			OccurredAt: r.OccurredAt,
			CreatedAt:  r.CreatedAt,
		})
	}
	return out, nil
}

// --- Scopes ---

func scopeEvidence(evidenceID string) func(*gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		return db.Where("evidence_id = ?", evidenceID)
	}
}

func scopeAction(a *Action) func(*gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		if a == nil || *a == "" {
			return db
		}
		return db.Where("action = ?", *a)
	}
}

func scopeActor(actorID *string) func(*gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		if actorID == nil || *actorID == "" {
			return db
		}
		return db.Where("actor_id = ?", *actorID)
	}
}

func scopeSince(since *time.Time) func(*gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		if since == nil || since.IsZero() {
			return db
		}
		return db.Where("occurred_at >= ?", *since)
	}
}

func scopeUntil(until *time.Time) func(*gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		if until == nil || until.IsZero() {
			return db
		}
		return db.Where("occurred_at <= ?", *until)
	}
}

func scopeOrder() func(*gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		return db.Order("occurred_at ASC").Order("created_at ASC")
	}
}

func scopePaginate(limit, offset int) func(*gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		if limit <= 0 || limit > 500 {
			limit = 100
		}
		if offset < 0 {
			offset = 0
		}
		return db.Limit(limit).Offset(offset)
	}
}
